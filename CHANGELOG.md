## Version History

### Workspace Import
Use this if you want a copy of the source for modifying in the editor.
```
{"workspaces":{"Adventure":[["analyze loot",":import adventure_lib\n:name {package}:analyze loot\n\n:global string leon.adventure.targetPositions\n\n:local string queue\n:local string idx\n:local vector curPos\n:local string targetPos\n:local string lootPositions\n\n#setField(index, value) lss(\"_f\" . {index}, {value})\n#getField(index) lsg(\"_f\" . {index})\n#setTPos(index, value) lss(\"_t\" . {index}, {value})\n#getTPos(index) lsg(\"_t\" . {index})\n\nqueue = {posToString(x(adventure.playerPos()), y(adventure.playerPos()))} . \"S:\"\n\n; On the first entry of this loop, the junk entry \"_f\" will be set to \"S\".\n; This has no effect.\n; In general, lootPositions, queue and setField are protected so that if the field\n; has already been set, we won't take action again.\nloop1:\ncurPos = {firstElementPos}\nidx = sub(queue, 0, 4)\nlootPositions = if(\\\n  {getField(idx)} == \"\"\\\n    && contains(adventure.entityType(curPos), \"Chest\"),\\\n  {posToString(x(curPos), y(curPos))} . \":\",\\\n  \"\") . lootPositions\n{setField(if({getField(idx)} != \"\", \"\", idx), {firstElementDir})}\nqueue = sub(queue, 6, 99999) . if({getField(idx)} != {firstElementDir},\\\n  \"\",\\\n  if(\\\n    adventure.isWall(curPos + vec(0., 1.)) || y(curPos) >= 18.,\\\n    \"\",\\\n    {posToString(x(curPos), y(curPos) + 1.)} . \"U:\"\\\n  ) . if(\\\n    adventure.isWall(curPos + vec(0., -1.)) || y(curPos) < 1.,\\\n    \"\",\\\n    {posToString(x(curPos), y(curPos) - 1.)} . \"D:\"\\\n  ) . if(\\\n    adventure.isWall(curPos + vec(1., 0.)) || x(curPos) >= 18.,\\\n    \"\",\\\n    {posToString(x(curPos) + 1., y(curPos))} . \"R:\"\\\n  ) . if(\\\n    adventure.isWall(curPos + vec(-1., 0.)) || x(curPos) < 1.,\\\n    \"\",\\\n    {posToString(x(curPos) - 1., y(curPos))} . \"L:\"\\\n  )\\\n)\ngotoif(loop1, queue != \"\")\n\ncontinue:\nlootPositions = leon.adventure.targetPositions . lootPositions\n\nloop2:\ntargetPos = sub(lootPositions, 0, 4)\ncurPos = {strToVec(targetPos)}\nlootPositions = sub(lootPositions, 5, 99999)\n\ninnerLoop2:\nidx = {posToString(x(curPos), y(curPos))}\nleon.adventure.targetPositions = if(\\\n  {getField({posToString(\\\n    x(curPos) - {nextX({getField(idx)})},\\\n    y(curPos) - {nextY({getField(idx)})}\\\n  )})} == \"S\"\\\n    && false == contains(leon.adventure.targetPositions, targetPos),\\\n  targetPos . \":\" . leon.adventure.targetPositions,\\\n  if(\\\n    false == contains(leon.adventure.targetPositions, targetPos) \\\n      && {getTPos(idx)} != \"\",\\\n      sub(\\\n        leon.adventure.targetPositions,\\\n        0,\\\n        index(leon.adventure.targetPositions, {getTPos(idx)}, 0)\\\n      )\\\n        . targetPos . \":\"\\\n        . sub(\\\n          leon.adventure.targetPositions,\\\n          index(leon.adventure.targetPositions, {getTPos(idx)}, 0),\\\n          99999\\\n        ),\\\n    leon.adventure.targetPositions\\\n  )\\\n)\n\n{setTPos(\\\n  idx,\\\n  if(\\\n    false == contains(leon.adventure.targetPositions, targetPos)\\\n      || {getTPos(idx)} == sub(leon.adventure.targetPositions, index(leon.adventure.targetPositions, targetPos, 0) + 5, 4),\\\n    targetPos,\\\n    {getTPos(idx)}\\\n  )\\\n)}\ncurPos -= {nextDir({getField(idx)})}\ngoto(if(\\\n  {getField({posToString(x(curPos), y(curPos))})} != \"S\",\\\n  innerLoop2,\\\n  if(len(lootPositions) > 0, loop2, end)\\\n))\n\nend:\nwait(0.)\n"],["clear room",":import adventure_lib\n:name {package}:clear room\n\n:global int leon.adventure.maxDifficulty\n:global string leon.adventure.path\n:global string leon.adventure.targetPositions\n\n:global string leon.adventure.room_direction\n:local double difficulty\n\n#nextRoomLower if(\\\n  x(adventure.roomCoords()) < 127.0 && y(adventure.roomCoords()) >= 127.0,\\\n  \"R\",\\\n  if(\\\n    x(adventure.roomCoords()) >= 127.0 && y(adventure.roomCoords()) > 127.0,\\\n    \"D\",\\\n    if(\\\n      x(adventure.roomCoords()) > 127.0 && y(adventure.roomCoords()) <= 127.0,\\\n      \"L\",\\\n      \"U\" \\\n    )\\\n  )\\\n)\n#rotateLeft(x) sub(\"LDRU\", index(\"ULDR\", {x}, 0), 1)\n#condRotateLeft(cond, x) sub(if({cond}, \"LDRU\", \"ULDR\"), index(\"ULDR\", {x}, 0), 1)\n\nexecutesync(\"{package}:kill enemies\")\nexecutesync(\"{package}:farm keys\")\n\n; We check based on current difficulty plus 1, because it's more efficient\n; that way.\ndifficulty = {cur_difficulty(1.)}\nleon.adventure.room_direction = if(\\\n  difficulty == 1. && leon.adventure.room_direction != \"\",\\\n  {rotateLeft(leon.adventure.room_direction)},\\\n  {condRotateLeft({survivable(difficulty)}, {nextRoomLower})}\\\n)\n\nleon.adventure.targetPositions = sub(\\\n    \"0918 0009 1809 0900\",\\\n    index(\"U    L    R    D\", leon.adventure.room_direction, 0),\\\n    4\\\n) . \":\"\n\nexecutesync(\"{package}:find loot\")\nleon.adventure.path = leon.adventure.room_direction\nexecutesync(\"{package}:follow path\")\nend:\nwait(0.)\n"],["farm keys",":import adventure_lib\n:name {package}:farm keys\n\n:global string leon.adventure.path\n:global bool leon.adventure.running\n\n:local string dir\n\ngoto(start)\n\nnext:\nleon.adventure.path = dir\nexecutesync(\"{package}:follow path\")\nexecutesync(\"{package}:kill enemies\")\nleon.adventure.path = sub(\"DURL\", index(\"UDLR\", dir, 0), 1)\nexecutesync(\"{package}:follow path\")\nexecutesync(\"{package}:kill enemies\")\nstart:\ndir = sub(\"XU   D  L  R\", index(\" 918 90 09 189\", x(adventure.playerPos()) . y(adventure.playerPos()), 0), 1)\ngoto(if(\\\n  adventure.keys() <= 10 && contains(\"UDLR\", dir) && leon.adventure.running,\\\n  next,\\\n  end\\\n))\nend:\nwait(0.)\n"],["find loot",":import adventure_lib\n:name {package}:find loot\n\n:global int turbo.cycles.max\n:global int turbo.cycles\n:global bool leon.adventure.running\n:global string leon.adventure.targetPositions\n:global int leon.adventure.maxDifficulty\n\nkey.u()\nkey.j()\n\nisopen(\"arcade\")\n\nleon.adventure.maxDifficulty +=\\\n  if(contains(impulse(), \"key.j\"), -1, if(contains(impulse(), \"key.u\"), 1, 0))\ngotoif(end, contains(impulse(), \"key.\"))\n\nstart:\nturbo.cycles.max = max(turbo.cycles.max, turbo.cycles + 4000)\nexecutesync(\"{package}:analyze loot\")\nloop:\nexecutesync(\"{package}:find path\")\nexecutesync(\"{package}:follow path\")\nleon.adventure.targetPositions = sub(leon.adventure.targetPositions, 5, 99999)\ngotoif(loop, len(leon.adventure.targetPositions) > 0 && leon.adventure.running)\nend:\nwait(0.)\n"],["find path",":import adventure_lib\n:name {package}:find path\n\n:global string leon.adventure.path\n:global string leon.adventure.targetPositions\n:global int turbo.cycles.max\n:global int turbo.cycles\n\n:local vector curPos\n:local string queue\n:local string idx\n:local string dir\n:local string path\n:local bool cantPhase\n\n#setField(index, value) lss(\"_f\" . {index}, {value})\n#getField(index) lsg(\"_f\" . {index})\n\nturbo.cycles.max = max(turbo.cycles.max, turbo.cycles + 4000)\nleon.adventure.path = \"\"\ncantPhase = false == adventure.hasItem(\"bootsPhasing\")\\\n|| 0 < max(\\\n  max(\\\n    max(\\\n      adventure.countEntities(\"Chest\"),\\\n      adventure.countEntities(\"Enemy\")\\\n    ),\\\n    adventure.countEntities(\"Elite\")\\\n  ),\\\n  adventure.countEntities(\"Mimic\")\\\n)\nqueue = {posToString(x(adventure.playerPos()), y(adventure.playerPos()))} . \"S:\"\nloop1:\ncurPos = {firstElementPos}\nidx = sub(queue, 0, 4)\n{setField(if({getField(idx)} != \"\", \"\", idx), {firstElementDir})}\nqueue = sub(queue, 6, 99999) . if({getField(idx)} != {firstElementDir},\\\n  \"\",\\\n  if(\\\n    adventure.isWall(curPos + vec(0., 1.)) && cantPhase\\\n      || max(x(curPos), y(curPos)) >= 18.\\\n      || x(curPos) < 1.,\\\n    \"\",\\\n    {posToString(x(curPos), y(curPos) + 1.)} . \"U:\"\\\n  ) . if(\\\n    adventure.isWall(curPos + vec(0., -1.)) && cantPhase\\\n      || min(x(curPos), y(curPos)) < 1.\\\n      || x(curPos) >= 18.,\\\n    \"\",\\\n    {posToString(x(curPos), y(curPos) - 1.)} . \"D:\"\\\n  ) . if(\\\n    adventure.isWall(curPos + vec(1., 0.)) && cantPhase\\\n      || max(x(curPos), y(curPos)) >= 18.\\\n      || y(curPos) < 1.,\\\n    \"\",\\\n    {posToString(x(curPos) + 1., y(curPos))} . \"R:\"\\\n  ) . if(\\\n    adventure.isWall(curPos + vec(-1., 0.)) && cantPhase\\\n      || min(x(curPos), y(curPos)) < 1.\\\n      || y(curPos) >= 18.,\\\n    \"\",\\\n    {posToString(x(curPos) - 1., y(curPos))} . \"L:\"\\\n  )\\\n)\ngoto(if(\\\n  queue == \"\" || contains(idx, sub(leon.adventure.targetPositions, 0, 4)),\\\n  l2start,\\\n  loop1\\\n))\n\nloop2:\nleon.adventure.path = dir . leon.adventure.path\ncurPos -= {nextDir(dir)}\nidx = {posToString(x(curPos), y(curPos))}\nl2start:\ndir = {getField(idx)}\ngotoif(loop2, dir != \"S\")\n\nexecutesync(\"{package}:refine path\")\nwait(0.0)\n"],["follow path",":import adventure_lib\n:name {package}:follow path\n\n:global string leon.adventure.path\n:global bool leon.adventure.running\n\n:local int stepCount\n:local vector curPos\n:local bool waitChest\n:local vector nextMove\n\n#nextDirection sub(leon.adventure.path, stepCount, 1)\n#nextMove {nextDir({nextDirection})}\n#curEntity adventure.entityType(curPos + {nextDir({nextDirection})})\n\ngoto(start)\n\nbomb:\nadventure.placeBomb()\ngoto(move)\n\nwait:\nadventure.wait()\n\nmove:\nstepCount += 1\nstart:\ncurPos = adventure.playerPos()\nnextMove = {nextMove}\nwaitChest = contains(adventure.entityType(adventure.playerPos() + nextMove), \"Chest\")\n\nmove2:\nexecutesync(\"TE2.2:stop\")\nadventure.move(nextMove)  ; This is a no-op for invalid (0,0) moves\nexecutesync(\"TE2.2:start\")\n\nloop:\n; This uses the spacing of unused values in the index expression to be equivalent\n; to lines to skip *backward*. This is much cheaper than having a nested ternary.\n; index returns -1 for the fallthrough case. (UDLR -> move)\ngoto(if(\\\n  stepCount < len(leon.adventure.path) && leon.adventure.running,\\\n  if(\\\n    contains(\"BW\", {nextDirection})\\\n      || x(curPos) != x(adventure.playerPos())\\\n      || y(curPos) != y(adventure.playerPos())\\\n      || waitChest && adventure.entityType(adventure.playerPos() + nextMove) == \"\",\\\n    (move - 1) - index(\"W B\", {nextDirection}, 0),\\\n    move2\\\n  ),\\\n  end\\\n))\n\nend:\nwait(0.)\n"],["init",":import adventure_lib\n:name {package}:init\n\n:global double leon.adventure.delay\n:global string leon.adventure.path\n:global bool leon.adventure.running\n:global int leon.adventure.maxDifficulty\n:global string leon.adventure.targetPositions\n:global string leon.adventure.room_direction\n:local int maxDifficultyInit\n\nkey.r()\nkey.i()\n\nisopen(\"arcade\")\n\nmaxDifficultyInit = 81\nleon.adventure.maxDifficulty = if(\\\n  contains(impulse(), \"key.i\") || leon.adventure.maxDifficulty == 0,\\\n  maxDifficultyInit,\\\n  leon.adventure.maxDifficulty\\\n)\n\ngoto(if(\\\n  contains(impulse(), \"key.i\"),\\\n  end,\\\n  if(leon.adventure.running, stop, start)\\\n))\nstart:\nexecutesync(\"TE2.2:start\")\ngis(\"<size=0>leon.adventure\",0)\nleon.adventure.running = true\nleon.adventure.path = \"\"\nleon.adventure.targetPositions = \"\"\nleon.adventure.room_direction = \"\"\ngss(\"---Stop hiding---\", \"</size=0>\")\nloop:\nexecutesync(\"{package}:clear room\")\nleon.adventure.maxDifficulty = leon.adventure.maxDifficulty + if(\\\n  {cur_difficulty(0.)} >= i2d(leon.adventure.maxDifficulty)\\\n    && adventure.isCompleted(adventure.roomCoords()),\\\n  2,\\\n  0\\\n)\ngotoif(loop, leon.adventure.running)\nexecutesync(\"TE2.2:stop\")\nstop:\nleon.adventure.running = false\nend:\nwait(0.)\n"],["kill enemies",":import adventure_lib\n:name {package}:kill enemies\n\n#enemyInDir(x, y) adventure.isEnemy(adventure.playerPos() + vec({x},{y}))\n#enemyDirection if({enemyInDir(0., 1.)}, vec(0., 1.),\\\n    if({enemyInDir(1., 0.)}, vec(1., 0.),\\\n    if({enemyInDir(0., -1.)}, vec(0., -1.),\\\n    if({enemyInDir(-1., 0.)}, vec(-1., 0.), vec(0., 0.)))))\n#anyEnemies {enemyInDir(0., 1.)} || {enemyInDir(0., -1.)} || {enemyInDir(1., 0.)} || {enemyInDir(-1., 0.)}\n\nkey.k()\n\nisopen(\"arcade\")\n\ngoto(if(contains(impulse(), \"key.\"), turbostart, loop))\nwait:\nadventure.wait()\n\nattack:\nexecutesync(\"TE2.2:stop\")\nadventure.move({enemyDirection})\n\nturbostart:\nexecutesync(\"TE2.2:start\")\n\nloop:\ngoto(if(\\\n  {anyEnemies},\\\n  attack,\\\n  if(\\\n    max(max(adventure.countEntities(\"Enemy\"), adventure.countEntities(\"Elite\")), adventure.countEntities(\"Mimic\")) > 0,\\\n    wait,\\\n    if(contains(impulse(), \"key.\"), stop, end)\\\n  )\\\n))\nstop:\nexecutesync(\"TE2.2:stop\")\nend:\nwait(0.)\n"],["refine path",":import adventure_lib\n:name {package}:refine path\n\n:global string leon.adventure.path\n\n:local vector curPos\n:local int stepCount\n\n#curDirection sub(leon.adventure.path, stepCount, 1)\n#insert(st,i,val) sub({st},0,{i}) . ({val}) . sub({st},{i},99999)\n#escapeDirection if(\\\n  adventure.entityType(curPos + vec(0., 1.)) == \"\"\\\n    && adventure.entityType(curPos + vec(0., 2.)) == \"\"\\\n    && false == adventure.isWall(curPos + vec(0., 1.))\\\n    && y(curPos) < 17.,\\\n  \"BUUWDD\",\\\n  if(\\\n    adventure.entityType(curPos + vec(0., -1.)) == \"\"\\\n      && adventure.entityType(curPos + vec(0., -2.)) == \"\"\\\n      && false == adventure.isWall(curPos + vec(0., -1.))\\\n      && y(curPos) > 1.,\\\n    \"BDDWUU\",\\\n    if(\\\n      adventure.entityType(curPos + vec(-1., 0.)) == \"\"\\\n        && adventure.entityType(curPos + vec(-2., 0.)) == \"\"\\\n        && false == adventure.isWall(curPos + vec(-1., 0.))\\\n        && x(curPos) > 1.,\\\n      \"BLLWRR\",\\\n      \"BRRWLL\"\\\n    )\\\n  )\\\n)\n\ncurPos = adventure.playerPos()\ngoto(start)\n\nrock:\nleon.adventure.path = {insert(\\\n  leon.adventure.path,\\\n  stepCount,\\\n  if(adventure.hasItem(\"eodArmor\"), \"BWWW\", {escapeDirection})\\\n)}\nstepCount += if(adventure.hasItem(\"eodArmor\"), 4, 6)\n\nnextTile:\ncurPos += {nextDir({curDirection})}\nstepCount += 1\n\nstart:\ngoto(if(\\\n  stepCount >= len(leon.adventure.path),\\\n  end,\\\n  if(\\\n    adventure.entityType(curPos + {nextDir({curDirection})}) != \"Rock\" || adventure.hasItem(\"hammer\"),\\\n    nextTile,\\\n    rock\\\n  )\\\n))\nend:\n    wait(0.)\n"],["adventure_lib","#package Adventure v3.1\n\n#strToVec(str) vec(s2d(sub({str}, 0, 2), -1.), s2d(sub({str}, 2, 2), -1.))\n#posToString(x, y) sub(d2s(({x}) + 200.), 1, 2) . sub(d2s(({y}) + 200.), 1, 2)\n#firstElementPos {strToVec(queue)}\n#firstElementDir sub(queue, 4, 1)\n#cur_difficulty(offset) (max(254. - x(adventure.roomCoords()), x(adventure.roomCoords())) + max(254. - y(adventure.roomCoords()), y(adventure.roomCoords())) + ({offset} - 254.))\n#survivable(difficulty) (\\\n  ceil(i2d(adventure.playerAttack()) * if(adventure.hasItem(\"impaler\"), 1.1, 1.)) >=\\\n    round({difficulty} * 0.38 + 1.) + round({difficulty} * 0.08)\\\n    || i2d(adventure.playerArmor()) >= ceil({difficulty} * 0.39)\\\n) && i2d(leon.adventure.maxDifficulty) >= {difficulty}\\\n  && (adventure.hasItem(\"lantern\") || {difficulty} < 100.)\n#nextX(d) s2d(sub(\"X 0 0 1-1\", index(\" U D R L\", {d}, 0), 2), 0.)\n#nextY(d) s2d(sub(\"X 1-1 0 0\", index(\" U D R L\", {d}, 0), 2), 0.)\n#nextDir(d) vec({nextX({d})}, {nextY({d})})\n"]]}}
```

### V3.1

Major bugfixes. Major size reduction.

Basic mimic handling, although it takes 2x as much damage as it needs to.

Boots of Phasing are used, Voidforged Impaler effect is accounted for in
determining maximum distance.

```
Bundle size: 43160   Scripts: 9   Max lines: 17
```

### V3.0

First release under new management!

Checks relics for EODArmor instead of assuming you have it at distance 50, and
uses hammer when possible instead of bombing all rocks.

Significantly smaller.

```
Bundle size: 98476   Scripts: 9   Max lines: 17
```

### V2.0.1

Last version by xWar131x.

```
Bundle size: 138196  Scripts: 9   Max lines: 18
```

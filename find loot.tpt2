:import adventure_lib
:name {package}:find loot
:budget_cap max

:global int leon.adventure.maxDifficulty
:global bool leon.adventure.running
:global string leon.adventure.path
:global string leon.adventure.room_direction

:local string queue
:local string idx
:local vector curPos
:local string targetPos
:local string lootPositions
:local string market_data

key.{decrement}()
key.{increment}()

isopen("arcade")

; Initialize variables so that pressing "{increment}" or "{decrement}" after resetting AI
; doesn't increment from 0
executesync(if(\
  contains(impulse(), "key."),\
  "{package}:init",\
  "{package}:xNOOPx"\
))
leon.adventure.maxDifficulty += if(\
  contains(impulse(), "key.{decrement}"),\
  -1,\
  if(contains(impulse(), "key.{increment}"), 1, 0)\
)
gotoif(end, contains(impulse(), "key."))

; Buy the first market item in our priority list that we don't have.
; We don't need to worry about checking for the market or available emeralds;
; if we can't buy the item, we'll simply fail to purchase and continue on.

; This Lua macro constructs a data table that is used to iterate over the items
; efficiently. The encoding is length-2 size, length-3 position, and
; variable-length data. The size and position are for locating the *next* item.
#data_table {lua(\
  local acc = {}\
  local item_str = "impaler,hammer,bootsPhasing,leechSword,manaReaver,eodArmor,thornsArmor,holyBomb,bookSpells"\
  local i = 3\
  for item in item_str:gmatch("%a+") do\
    acc[i] = item\
    i = i + 3\
  end\
  i = 3\
  pos = 0\
  while acc[i] do\
    pos = pos + 5 + #acc[i]\
    acc[i-2] = string.format("%02d", #(acc[i+3] or "") + 5)\
    acc[i-1] = string.format("%03d", pos)\
    i = i + 3\
  end\
  return table.concat(acc)\
)}

market_loop:
market_data = sub(\
  "{data_table}",\
  s2i(sub(market_data, 2, 3), 0),\
  s2i(sub(market_data, 0, 2), 12)\
)
; Loop until we find an unbought item. By the nature of hasItem, it will
; always return false for the empty string at the end of the loop, so we
; don't need an explicit end check.
gotoif(market_loop, adventure.hasItem(sub(market_data, 5, 99)))
adventure.buyMarketItem(sub(market_data, 5, 99))

; Turn our room direction into a target exit via lookup-table.
global.string.set({target_pos_var}, sub(\
    "0918 0009 1809 0900",\
    index("U    L    R    D", leon.adventure.room_direction, 0),\
    4\
) . ":")

#setField(index, value) lss("_f" . {index}, {value})
#getField(index) lsg("_f" . {index})
#setTPos(index, value) lss("_t" . {index}, {value})
#getTPos(index) lsg("_t" . {index})

queue = {posToString(x(adventure.playerPos()), y(adventure.playerPos()))} . "S:"

; On the first entry of this loop, the junk entry "_f" will be set to "S".
; This has no effect.
; In general, lootPositions, queue and setField are protected so that if the field
; has already been set, we won't take action again.
loop1:
curPos = {firstElementPos}
idx = sub(queue, 0, 4)
lootPositions = if(\
  {getField(idx)} == ""\
    && contains(adventure.entityType(curPos), "Chest"),\
  {posToString(x(curPos), y(curPos))} . ":",\
  "") . lootPositions
{setField(if({getField(idx)} != "", "", idx), {firstElementDir})}
queue = sub(queue, 6, 99999) . if({getField(idx)} != {firstElementDir},\
  "",\
  if(\
    adventure.isWall(curPos + vec(0., 1.)) || y(curPos) >= 18.,\
    "",\
    {posToString(x(curPos), y(curPos) + 1.)} . "U:"\
  ) . if(\
    adventure.isWall(curPos + vec(0., -1.)) || y(curPos) < 1.,\
    "",\
    {posToString(x(curPos), y(curPos) - 1.)} . "D:"\
  ) . if(\
    adventure.isWall(curPos + vec(1., 0.)) || x(curPos) >= 18.,\
    "",\
    {posToString(x(curPos) + 1., y(curPos))} . "R:"\
  ) . if(\
    adventure.isWall(curPos + vec(-1., 0.)) || x(curPos) < 1.,\
    "",\
    {posToString(x(curPos) - 1., y(curPos))} . "L:"\
  )\
)
gotoif(loop1, queue != "")

continue:
lootPositions = {target_positions} . lootPositions

loop2:
targetPos = sub(lootPositions, 0, 4)
curPos = {strToVec(targetPos)}
lootPositions = sub(lootPositions, 5, 99999)

innerLoop2:
idx = {posToString(x(curPos), y(curPos))}
global.string.set({target_pos_var}, if(\
  {getField({posToString(\
    x(curPos) - {nextX({getField(idx)})},\
    y(curPos) - {nextY({getField(idx)})}\
  )})} == "S"\
    && false == contains({target_positions}, targetPos),\
  targetPos . ":" . {target_positions},\
  if(\
    false == contains({target_positions}, targetPos) \
      && {getTPos(idx)} != "",\
      sub(\
        {target_positions},\
        0,\
        index({target_positions}, {getTPos(idx)}, 0)\
      )\
        . targetPos . ":"\
        . sub(\
          {target_positions},\
          index({target_positions}, {getTPos(idx)}, 0),\
          99999\
        ),\
    {target_positions}\
  )\
))

{setTPos(\
  idx,\
  if(\
    false == contains({target_positions}, targetPos)\
      || {getTPos(idx)} == sub({target_positions}, index({target_positions}, targetPos, 0) + 5, 4),\
    targetPos,\
    {getTPos(idx)}\
  )\
)}
curPos -= {nextDir({getField(idx)})}
goto(if(\
  {getField({posToString(x(curPos), y(curPos))})} != "S",\
  innerLoop2,\
  if(len(lootPositions) > 0, loop2, main_loop)\
))

main_loop:
executesync("{package}:find path")
executesync("{package}:follow path")
global.string.set({target_pos_var}, sub({target_positions}, 5, 99999))
gotoif(main_loop, {target_positions} != "" && leon.adventure.running && adventure.playerHealth() > 0)

leon.adventure.path = leon.adventure.room_direction
executesync("{package}:follow path")
end:
